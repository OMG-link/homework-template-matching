# Template Matching

## 功能概述

基于C++的模板匹配实现，目前实现了：

1. 基本的匹配方法

   ```cpp
   bool Match( unsigned char Target[256][256], unsigned char Template[64][64], int& X, int& y );
   ```

2. 加速的匹配方法

   ```cpp
   bool Match_accelerated( unsigned char Target[256][256], unsigned char Template[64][64], int& X, int& y )
   ```

3. 支持角度检测的匹配方法

   ```cpp
   float Match_also_orient( unsigned char Target[256][256], unsigned char Template[64][64], int& X, int& y )
   ```

4. 支持放缩检测的匹配方法

   ```cpp
   float Match_also_scale( unsigned char Target[256][256], unsigned char Template[64][64], int& X, int& y )
   ```

没有实现亚像素的匹配方法，因为个人认为在噪声的干扰下，结果的不确定度大于像素级，求解亚像素级的匹配位置没有意义。

## 使用方法

1. 构建可执行程序

   ```bash
   ./build.sh [-g]
   ```

2. 运行测试用例

   ```bash
   ./run.sh <用例目录>
   ```

   例如：

   ```bash
   ./run.sh test-data/pdf-example
   ```

## 项目结构

### src

模板匹配的源代码目录，存放了模板匹配用到的所有源代码

### test-data

测试用例目录，存放了一些测试用例。

#### 测试用例结构

每个测试用例为一个文件夹，其中必须包含 `image.txt` 和 `template.txt` ，可能包含 `image.jpg` 和 `template.jpg` 。

以 `.txt` 结尾的文件为文本形式的灰度图文件，是 C++ 代码读取的数据源。

以 `.jpg` 结尾的文件是灰度图的可视化版本，方便调试使用，C++代码事实上不会操作这些文件。

### tool

存放了项目编辑过程中用到的一些自建工具。

## 算法概述

### 1. 基本的匹配方法

采用四重循环计算每个匹配位置的得分。一个匹配位置的得分定义为所有对应位置像素差值的平方的和，即：
$$
\sum_{i,j} (s_{i+x,j+y}-t_{i,j})^2
$$

### 2. 加速的匹配方法

将得分表达式展开：
$$
\sum_{i,j} s_{i+x,j+y}^2+\sum_{i,j} t_{i,j}^2 - \sum_{i,j} 2s_{i+x,j+y}t_{i,j}
$$
设图片的像素总数为 $n$ 。

第一项可以用FFT在 $O(n \log n)$ 的时间内求出所有 $(x,y)$ 的 $\sum_{i,j} s_{i+x,j+y}^2$ 。（该项也可以用二维差分在 $O(n)$ 的时间内计算所有 $(x,y)$ 的结果，但该方法不适合旋转后的匹配过程）

第二项对于所有 $(x,y)$ 都是定值，因此可以预先计算，占用 $O(n)$ 的复杂度。

第三项可以用FFT在 $O(n \log n)$ 的时间内求出所有 $(x,y)$ 的 $\sum_{i,j} s_{i+x,j+y}t_{i,j}$ 。

总复杂度为 $O(n \log n)$ 。

### 3. 支持角度检测的匹配方法

将模板图的旋转角度作为函数参数，匹配得分作为函数值。该问题实际上是一个一维的最优化问题。

基于实际问题，本项目的做法为：

1. 在参数内平均选取 $16$ 个采样点。
2. 考虑采样点中函数值的“谷底”部分。
3. 对“谷底”部分，在其两侧各一个采样点围成的范围内，采用三分法寻找极值。

朴素的实现运行较为缓慢，本项目还加入了若干优化，包括：

- 使用两次DFT的FFT。
- 使用黄金分割比进行三分，而非平均三分。
- 在三分时仅裁剪原图的一小部分进行匹配。

最终，单次调用需要运行约500ms。

### 4. 支持放缩检测的匹配方法

类似于角度检测，该问题同样可以抽象为：将模板图的放缩比作为函数参数，匹配得分作为函数值的最优化问题。

基于实际问题，本项目的做法为：

1. 在参数内按几何分布选取 $8$ 个采样点。
2. 考虑采样点中函数值的“谷底”部分。
3. 对“谷底”部分，在其两侧各一个采样点围成的范围内，采用三分法寻找极值。

同样的，该方法使用了若干优化，包括：

- 使用两次DFT的FFT。
- 使用黄金分割比进行三分，而非平均三分。

最终，单次调用需要运行约400ms。